#!/usr/bin/env python3
"""
auto-brightness — Ambient Light Sensor auto-brightness for Asahi Linux

Controls display brightness through KDE's ScreenBrightness D-Bus API
with SuppressIndicator flag (no OSD popups). Reads lux directly from
the IIO sensor sysfs node for low latency.

Architecture:
  - KDE D-Bus with flag=1 (SuppressIndicator): slider tracks smoothly,
    no OSD popups, no conflict with powerdevil
  - One brightness step per poll cycle: imperceptible transitions
  - Manual override: respects user slider changes until ambient light
    shifts by ≥50% (or ≥5 lux absolute in low light)
  - Reads lux directly from IIO sysfs (no iio-sensor-proxy dependency)

Designed for Apple Silicon laptops running Asahi Linux with the VD6286
ALS sensor driven by the aop_als kernel module.

Usage:
  auto-brightness                              # run in foreground
  systemctl --user start auto-brightness       # via systemd

Requires:
  - Kernel with aop_als module (IIO ALS sensor)
  - KDE Plasma 6+ (provides org.kde.ScreenBrightness on session bus)
  - python3-dbus
"""

import dbus
import os
import signal
import sys
import time

# ---------------------------------------------------------------------------
# Hardware paths
# ---------------------------------------------------------------------------

SENSOR_FILE = "/sys/bus/iio/devices/iio:device1/in_illuminance_input"

# ---------------------------------------------------------------------------
# Tuning constants
# ---------------------------------------------------------------------------

POLL_INTERVAL = 0.25        # seconds between sensor reads
SMOOTH_STEP = 100           # KDE brightness units per cycle (1% of 10000)

LUX_CHANGE_PCT = 75         # % lux change to resume after manual override
LUX_CHANGE_MIN = 5          # absolute lux change minimum (for dark conditions)

MIN_BRIGHTNESS = 200        # floor (KDE units out of 10000)
MAX_BRIGHTNESS = 10000

# Lux → brightness % curve (linearly interpolated)
LUX_CURVE = [
    (0,     2),
    (1,     3),
    (5,     6),
    (20,   12),
    (50,   24),
    (100,  40),
    (200,  60),
    (400,  80),
    (700,  92),
    (1000, 100),
]

# ---------------------------------------------------------------------------
# Sysfs lux reader
# ---------------------------------------------------------------------------

def read_lux():
    """Read lux from IIO sensor sysfs (returns int or None)."""
    try:
        with open(SENSOR_FILE, "r") as f:
            return int(f.read().strip())
    except Exception:
        return None

# ---------------------------------------------------------------------------
# KDE D-Bus brightness control
# ---------------------------------------------------------------------------

def kde_connect():
    """Create persistent KDE D-Bus proxy objects."""
    bus = dbus.SessionBus()
    obj = bus.get_object(
        "org.kde.ScreenBrightness",
        "/org/kde/ScreenBrightness/display0",
    )
    display = dbus.Interface(obj, "org.kde.ScreenBrightness.Display")
    props = dbus.Interface(obj, "org.freedesktop.DBus.Properties")
    return display, props

def kde_get(props):
    """Read current brightness from KDE (returns int or None)."""
    try:
        return int(props.Get("org.kde.ScreenBrightness.Display", "Brightness"))
    except Exception:
        return None

def kde_set(display, val):
    """Set brightness via KDE D-Bus with SuppressIndicator (no OSD)."""
    val = max(MIN_BRIGHTNESS, min(int(val), MAX_BRIGHTNESS))
    try:
        display.SetBrightness(dbus.Int32(val), dbus.UInt32(1))
    except Exception:
        pass

# ---------------------------------------------------------------------------
# Lux → brightness mapping
# ---------------------------------------------------------------------------

def lux_to_brightness(lux):
    """Map a lux value to KDE brightness units (0–10000) via LUX_CURVE."""
    if lux <= LUX_CURVE[0][0]:
        pct = LUX_CURVE[0][1]
    elif lux >= LUX_CURVE[-1][0]:
        pct = LUX_CURVE[-1][1]
    else:
        pct = 50
        for i in range(len(LUX_CURVE) - 1):
            l0, b0 = LUX_CURVE[i]
            l1, b1 = LUX_CURVE[i + 1]
            if l0 <= lux <= l1:
                t = (lux - l0) / (l1 - l0)
                pct = b0 + t * (b1 - b0)
                break
    return max(MIN_BRIGHTNESS, min(MAX_BRIGHTNESS,
               int(round(pct / 100.0 * MAX_BRIGHTNESS))))

# ---------------------------------------------------------------------------
# Manual override detection
# ---------------------------------------------------------------------------

def lux_changed_enough(current_lux, override_lux):
    """Check if ambient light has changed enough to resume auto-brightness."""
    delta = abs(current_lux - override_lux)
    if delta < LUX_CHANGE_MIN:
        return False
    if override_lux == 0:
        return True
    return (delta * 100 / override_lux) >= LUX_CHANGE_PCT

# ---------------------------------------------------------------------------
# Main loop
# ---------------------------------------------------------------------------

def main():
    if not os.path.exists(SENSOR_FILE):
        print(f"auto-brightness: missing {SENSOR_FILE}", flush=True)
        sys.exit(1)

    display, props = kde_connect()

    current = kde_get(props)
    if current is None:
        print("auto-brightness: cannot read KDE brightness, exiting", flush=True)
        sys.exit(1)

    print(f"auto-brightness: KDE D-Bus (SuppressIndicator), "
          f"step={SMOOTH_STEP}, poll={POLL_INTERVAL}s, "
          f"initial={current}/10000", flush=True)

    signal.signal(signal.SIGTERM, lambda *_: sys.exit(0))
    signal.signal(signal.SIGINT, lambda *_: sys.exit(0))

    last_set = current          # what WE last set via D-Bus
    manual_override = False
    override_lux = 0
    idle_cycles = 0             # how many cycles we've been at target

    while True:
        time.sleep(POLL_INTERVAL)

        lux = read_lux()
        if lux is None:
            continue

        target = lux_to_brightness(lux)

        # Only check for manual override when idle (at target for a while).
        # During active ramping, powerdevil interferes with readback so we
        # trust our own internal position and never read KDE brightness.
        if idle_cycles >= 4:
            actual = kde_get(props)
            if actual is not None and abs(actual - last_set) > SMOOTH_STEP * 3:
                if not manual_override:
                    print(f"auto-brightness: manual override "
                          f"(ours={last_set}, slider={actual})", flush=True)
                manual_override = True
                override_lux = lux
                current = actual
                last_set = actual
                idle_cycles = 0
                continue

        # In manual override: wait for significant lux change
        if manual_override:
            if lux_changed_enough(lux, override_lux):
                # Re-read KDE brightness FIRST so we ramp from the
                # user's current position, not our stale internal value.
                actual = kde_get(props)
                if actual is not None:
                    current = actual
                    last_set = actual
                manual_override = False
                print(f"auto-brightness: resuming at {current}/10000 "
                      f"(lux {override_lux}->{lux})", flush=True)
            else:
                continue

        # Already at target: count idle cycles
        if current == target:
            idle_cycles = min(idle_cycles + 1, 100)
            continue

        # Actively ramping: reset idle counter
        idle_cycles = 0

        if current < target:
            current = min(current + SMOOTH_STEP, target)
        else:
            current = max(current - SMOOTH_STEP, target)

        kde_set(display, current)
        last_set = current


if __name__ == "__main__":
    main()
